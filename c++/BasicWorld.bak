#include <iostream>
//using std::ios;

#include <fstream>
//using std::ifstream;
//using std::ofstream;

#include <sstream>

#include <string>
//using std::string;
#include <vector>
//using std::vector;
#include <exception>
#include <algorithm>

using namespace std; 

#include "btBulletDynamicsCommon.h"
#include "btBulletCollisionCommon.h"
#include "GlutStuff.h"
#include "GL_ShapeDrawer.h"

#include "BasicWorld.h"

#define COMMENTS true 

// Setup Collision Callback

static BasicWorld* basicWorld;

bool myContactProcessedCallback(btManifoldPoint& cp, void* body0, void* body1)
{
  int *ID1, *ID2;
  btCollisionObject* o1 = static_cast<btCollisionObject*>(body0);
  btCollisionObject* o2 = static_cast<btCollisionObject*>(body1);
  int groundID = 0;
  
  ID1 = static_cast<int*>(o1->getUserPointer());
  ID2 = static_cast<int*>(o2->getUserPointer());

  //printf("ID1 = %d, ID2 = %d\n", *ID1, *ID2);
  
  basicWorld->touches[*ID1] = 1;
  basicWorld->touches[*ID2] = 1;
  basicWorld->touchPoints[*ID1] = cp.m_positionWorldOnB;
  basicWorld->touchPoints[*ID2] = cp.m_positionWorldOnB;

  return false;
}


// Initialize World

void BasicWorld::initPhysics()
{

  //collision stuff
  basicWorld = this;
  gContactProcessedCallback = myContactProcessedCallback;

  
  // ============= Getting, Manipulating, and Storing Blueprints ====================
  
  ifstream blueprintFile("/home/josh/Documents/projects/thesis/coding/trial/python/blueprint.dat");
  
  //input 
  vector<string> body_strings;
  vector<string> joint_strings;
  vector<string> neuron_strings;
  vector<string> sensor_strings;
  vector<string> wire_strings;

  //holders to pass data through
  int i_hold;
  vector<long double> l_hold;
  vector<vector<long double > > dl_hold;
  string holder;
  int count = 0;
  
  while (getline(blueprintFile, holder))
    { 
      // Set line as string to get data from
      istringstream s(holder);     
      // Skip empty lines
      if (holder.empty())
	{
	  count ++;
	  continue;
	}
      // Body Part Section
      if (count < 8)
	{ 
	  // If empty skip to next section
	  if (holder[0] == 'E')
	    {
	      count = 8;
	      continue;
	    }
	  // Otherwise see where you are in count, and fill accordingly 
	  if (count==0 || count==3 || count==5 || count==6)
	    { 
	      while (getline(s, holder, ','))
		{
		  i_hold = stoi(holder);
		  if (count==0){body_indexs.push_back(i_hold);}
		  if (count==3){body_j_nums.push_back(i_hold);}
		  if (count==5){body_n_nums.push_back(i_hold);}
		  if (count==6){body_s_nums.push_back(i_hold);}
		}
	    }
	  
	  if (count==1)
	    {
	      while (getline(s, holder, ','))
		{body_kinds.push_back(holder);}
	    }
	  
	  if (count==2)
	    {
	      while (getline(s, holder, ','))
		{ d_hold = stod(holder);
		  body_sizes.push_back(d_hold);}
	    }
	  
	  if (count==4 || count==7)
	    {
	      while (getline(s, holder,'|'))
		{
		  dl_hold.clear();
		  istringstream s2(holder);
		  while (getline(s2, holder, ';'))
		    {
		      l_hold.clear();
		      istringstream s3(holder);
		      while (getline(s3, holder, ','))
			{
			  d_hold = stod(holder);
			  l_hold.push_back(d_hold);
			}
		      dl_hold.push_back(l_hold);
		    }
		  if (count==4){body_j_locs.push_back(dl_hold);}
		  if (count==7){body_s_locs.push_back(dl_hold);}
		}
	    }
	  count++;
	  continue;
	}
      // Joint Part Section
      else if ((count > 8) && (count < 15))
	{
	  if (holder[0] == 'E')
	    { 
	      count = 14;
	      continue;
	    }
	  if (count==9)
	    {
	      while (getline(s, holder, ','))
		{
		  i_hold = stoi(holder);
		  joint_indexs.push_back(i_hold);
		}
	    }
	  if (count==10||count==11)
	    {
	      while (getline(s, holder, ','))
		{
		  if (holder[0]=='T')
		    { if (count==10)
			{joint_motors.push_back(true);}
		      if (count==11)
			{joint_frees.push_back(true);}
		    }
		  if (holder[0]=='F')
		    { if (count==10)
			{joint_motors.push_back(false);}
		      if (count==11)
			{joint_frees.push_back(false);}
		    }
		}
	    }
      	  if (count==12||count==13)
	    {
	      while (getline(s, holder, ','))
		{
		  d_hold = stod(holder);
		  if (count==12)
		    {joint_u_limits.push_back(d_hold);}
		  if (count==13)
		    {joint_l_limits.push_back(d_hold);}
		}
	    }
	  if (count==14)
	    while (getline(s, holder, ','))
	      {
		i_hold = stoi(holder);
		joint_inputs.push_back(i_hold);
	      }
	  
	  count++;
	  continue;
	}
      // Neuron Part Section
      else if ((count > 15) && (count < 19))
	{
	  if (holder[0] == 'E')
	    {
	      count = 19;
	      continue;
	    }
	  
	  while (getline(s, holder, ','))
	    {
	      i_hold = stoi(holder);
	      if (count==16)
		{neuron_indexs.push_back(i_hold);}
	      if (count==17)
		{neuron_inputs.push_back(i_hold);}
	      if (count==18)
		{neuron_outputs.push_back(i_hold);}
	    }
	  
	  count ++;
	  continue;
	}
      // Sensor Part Section 
      else if ((count > 19) && (count < 22))
	{ 
	  if (holder[0] == 'E')
	    {
	      count = 22;
	      continue;
	    }
	  if (count==20)
	    {
	      while (getline(s, holder, ','))
		{ i_hold = stoi(holder);
		  sensor_indexs.push_back(i_hold);}
	    }
	  if (count==21)
	    {
	      while (getline(s, holder, ','))
		{ i_hold = stoi(holder);
		  sensor_outputs.push_back(i_hold);}
	    }
	  count ++;
	  continue;
	}
      // Wire Part Section
      else if ((count > 22) && (count < 26))
	{
	  if (holder[0] == 'E')
	    {
	      count = 26;
	      continue;
	    }
	  if (count==23)
	    {
	      while (getline(s, holder, ','))
		{ i_hold = stoi(holder);
		  wire_indexs.push_back(i_hold);}
	    }
	  if (count==24)
	    {
	      while (getline(s, holder, ','))
		{ d_hold = stod(holder);
		  wire_weights.push_back(d_hold);}
	    }
	  if (count==25)
	    {
	      while (getline(s, holder, ','))
		{ 
		  if (holder[0]=='T')
		    { wire_directs.push_back(true);}
		  if (holder[0]=='F')
		    { wire_directs.push_back(false);}
		}
	    }
	  count ++;
	  continue;
	}    
    }

  // Set IDs and touches
  for (int i=0;i<body_indexs.size();i++)
    { 
      IDs.push_back(i);
      touches.push_back(0);
      touchPoints.push_back(btVector3(0.,0.,0.));
    }
  
  timeStep = 0;
  
  // Print out imported info
  if (COMMENTS)
    {
      PrintTestI(body_indexs);
      PrintTestS(body_kinds);
      PrintTestD(body_sizes);
      PrintTestI(body_j_nums);
      PrintTest2(body_j_locs);
      PrintTestI(body_n_nums);
      PrintTestI(body_s_nums);
      PrintTest2(body_s_locs);
      cout << endl;
      
      PrintTestI(joint_indexs);
      PrintTestB(joint_motors);
      PrintTestB(joint_frees);
      PrintTestD(joint_u_limits);
      PrintTestD(joint_l_limits);
      PrintTestI(joint_inputs);
      cout << endl;

      PrintTestI(neuron_indexs);
      PrintTestI(neuron_inputs);
      PrintTestI(neuron_outputs);
      cout << endl;
      
      PrintTestI(sensor_indexs);
      PrintTestI(sensor_outputs);
      cout << endl;
      
      PrintTestI(wire_indexs);
      PrintTestD(wire_weights);
      PrintTestB(wire_directs);
      cout << endl;
    }
 

  // ============== Basic World Setup =================
  
  //Texture, Cameras, and Shadows
  setTexturing(true);
  setShadows(true);
  
  setCameraDistance(btScalar(30.));
  
  //Setup and build Broadphase
  btVector3 worldAabbMin(-10000,-10000,-10000);
  btVector3 worldAabbMax(10000,10000,10000);
  //btBroadphaseInterface* define is in .h file 
  m_broadphase = new btAxisSweep3 (worldAabbMin, worldAabbMax);

  //Setup collision configuration and dispatcher
  //btDefaultCollisionConfiguration* define is in .h file 
  m_collisionConfiguration = new btDefaultCollisionConfiguration();
  //btCollisionDispatcher* define is in .h file 
  m_dispatcher = new btCollisionDispatcher(m_collisionConfiguration);

  // Physics solver
  //btConstraintSolver* define is in .h file 
  m_solver = new btSequentialImpulseConstraintSolver;

  // The world
  //btDiscreteDynamicsWorld* define is in .h file 
  m_dynamicsWorld = new btDiscreteDynamicsWorld(m_dispatcher, m_broadphase, m_solver, m_collisionConfiguration);
  // Don't forget the gravity!
  m_dynamicsWorld->setGravity(btVector3(0, -9.81, 0));

  // ================ Objects  ========================

  // Ground and sphere collision shape variables
  //btCollisionShape* define is in .h file 

  btCollisionShape* groundShape = new btStaticPlaneShape(btVector3(0, 1, 0), 1);

  btTransform groundTransform;
  groundTransform.setIdentity();
  groundTransform.setOrigin(btVector3(0,-1,0));
  
  btCollisionObject* fixedGround = new btCollisionObject();
  fixedGround->setCollisionShape(groundShape);
  fixedGround->setWorldTransform(groundTransform);
  fixedGround->setUserPointer(&IDs[0]);
  m_dynamicsWorld->addCollisionObject(fixedGround);
  
  /*
  btCollisionShape* groundShape = new btBoxShape(btVector3(btScalar(2000.),btScalar(10.),btScalar(2000.)));
  m_collisionShapes.push_back(groundShape);

  // Defining the ground
  {
  btTransform groundTransform;
  groundTransform.setIdentity();
  groundTransform.setOrigin(btVector3(0,-10,0));

#define CREATE_GROUND_COLLISION_OBJECT 1
#ifdef CREATE_GROUND_COLLISION_OBJECT
  btCollisionObject* fixedGround = new btCollisionObject();
  fixedGround->setCollisionShape(groundShape);
  fixedGround->setWorldTransform(groundTransform);
  fixedGround->setUserPointer(&IDs[0]);
  m_dynamicsWorld->addCollisionObject(fixedGround);
#else
  localCreateRigidBody(btScalar(0.),groundTransform,groundShape);
#endif
  }
  */

  
  
  //=================== Creating Body Parts and Joints ================================
  
  // these hold all create information
  vector<vector<btScalar> > parts_to_build;
  vector<vector<btScalar> > hinges_to_build;
  vector<btScalar> tb_holder;

  // the following three use same indexing as BP bodies
  vector<btVector3> bp_locations;
  
  vector<int> built_body(body_indexs.size(), 0);
  
  vector<int> tossed_bodys(body_indexs.size(), 0);
  vector<int> used_joints(body_indexs.size(), 0);
  // Note, "used_joints" can be used as an index for the current joint to use: e.g.
  // if one joint has been used, the second joint (indexed as 1) will be called.
  // Indexed like bp_attributes

  // index of current part in bp_attribute lists
  int index = 0;
  // index of BP joints
  int j_index = 0;
  // index of BP bodies
  // b_index[n] is the b_number for bodypart associated with index n
  vector<int> b_index(body_indexs.size(), 0);

  // vars for locs of bp, joint, and joint-axis.
  btScalar x = 0.;
  btScalar y = 0.;
  btScalar z = 0.;
  btScalar j_x;
  btScalar j_y;
  btScalar j_z;
  btScalar a_x = 1.;
  btScalar a_y = 0.;
  btScalar a_z = 0.;

  // index of bp_attributes for base of next part
  int base_index = 0;
  // accumilator of BPs tossed
  int t_acc = 0;
  // accumilator of BPs used
  int b_acc = 0;
  // catches wild while loop
  int catcher = 0;
  
  do
    {   
      if (COMMENTS)
	{
	  cout << endl;
	  cout << "Index: " << index << "| B_Index: " << b_index[index] << "| Joints total: " << body_j_nums[index] << "| Joints used: " << used_joints[index] << endl;
	  cout << "Base Index: " << base_index << "| B_Index: " << b_index[base_index] << "| Joints total: " << body_j_nums[base_index] << "| Joints used: " << used_joints[base_index] << endl;
	} 
      // First part gets built at origin
      if (bp_locations.empty())
	{
	  if (body_j_nums[index] > 0)
	    {
	      //CreateSphere(b_index[b_acc], x, y, z, body_sizes[index]);
	      tb_holder.push_back(b_index[b_acc]);
	      tb_holder.push_back(x);
	      tb_holder.push_back(y);
	      tb_holder.push_back(z);
	      tb_holder.push_back(body_sizes[index]);
	      parts_to_build.push_back(tb_holder);
	      tb_holder.clear();
	      built_body[index] = 1;
	      bp_locations.push_back(btVector3(x,y,z));
	      base_index = index;
	      index++;
	      b_acc++;
	      if (COMMENTS)
		{
	      cout << "Made object " << (index-1) << endl;
	      cout << "b_index: " << b_index[index-1] << endl;
		}
	    }
	  else 
	    {
	      //No Joint mounts, toss it
	      tossed_bodys[index] = 1;
	      t_acc++;
	      index++;
	      //if no part has joints, bail
	      if (index >= body_indexs.size())
		{
		  if (COMMENTS)
		    {
		  cout << "Bailed at start" << endl;
		    }
		  break;
		}
	      if (COMMENTS)
		{
		  cout << "Skipped object " << index-1 << " at 1" << endl;
		  cout << "J_num = " << body_j_nums[index-1] << endl;
		}
	      continue;
	    }
	}
      
      // index out of range? Start at begining!
      else if (index >= body_indexs.size())
	{ index = 0;
	  if (COMMENTS)
	    {
	      cout << "Out of range. Reset." << endl;
	    }
	}

      // Index is the same as base? Get next index!
      else if (index==base_index)
	{ index++;
	  if (COMMENTS)
	    {
	      cout << "Index and base equal..." << endl;
	    }
	}
     
      //maybe not needed because of last conditions
      // Built or tossed index? Go to the next one!
      else if (built_body[index]==1 || tossed_bodys[index]==1)
	{ index++;
	  if (COMMENTS)
	    {
	      cout << "Already used or tossed body " << index-1 << endl;
	    }
	}
      // No Joint Mounts? Toss it! 
      else if (body_j_nums[index]==0)
	{
	  tossed_bodys[index] = 1;
	  t_acc++;
	  index ++;
	  if (COMMENTS)
	    {
	      cout << "Skipped object " << (index-1) << " at 2" << endl;
	      cout << "J_num = " << body_j_nums[index-1] << endl;
	    }
	}
      // All other parts while they have a joint loc and base has free joint loc
      else if ((used_joints[index] < body_j_nums[index]) && (used_joints[base_index] <body_j_nums[base_index]))
	{
	  /*
	  while ((used_joints[index] < body_j_nums[index]) && (used_joints[base_index] < body_j_nums[base_index]) && index < body_indexs.size())
	    
	  {
	  */
	  // Set position vars of joint
	  if (COMMENTS)
	    {
	      cout << "Base Position: " << bp_locations[b_index[base_index]].x() << ',' << bp_locations[b_index[base_index]].y() << ',' << bp_locations[b_index[base_index]].z() << endl;
	      cout << "Base Size: " << body_sizes[base_index] << endl;
	    }
	  j_x = bp_locations[b_index[base_index]].x() + (body_sizes[base_index] * body_j_locs[base_index][used_joints[base_index]][0]);
	  j_y = bp_locations[b_index[base_index]].y() + (body_sizes[base_index] * body_j_locs[base_index][used_joints[base_index]][1]);
	  j_z = bp_locations[b_index[base_index]].z() + (body_sizes[base_index] * body_j_locs[base_index][used_joints[base_index]][2]);
	  if (COMMENTS)
	    {cout << "New Joint Position " << j_x << ',' << j_y << ',' << j_z << endl;}
	  // Set position vars of part
	  x = j_x - (body_sizes[index] * body_j_locs[index][used_joints[index]][0]);
	  y = j_y - (body_sizes[index] * body_j_locs[index][used_joints[index]][1]);
	  z = j_z - (body_sizes[index] * body_j_locs[index][used_joints[index]][2]);
	  if (COMMENTS)
	    {
	      cout << "New Part Size: " << body_sizes[index] << endl;
	      cout << "New Part Position: " << x << ',' << y << ',' << z << endl;
	    }
	  //Create next part
	  //but first set b_index for new part
	  b_index[index] = b_acc;
	  //CreateSphere(b_index[index], x, y, z, body_sizes[index]);
	  tb_holder.push_back(b_index[index]);
	  tb_holder.push_back(x);
	  tb_holder.push_back(y);
	  tb_holder.push_back(z);
	  tb_holder.push_back(body_sizes[index]);
	  parts_to_build.push_back(tb_holder);
	  tb_holder.clear();
	  built_body[index] = 1;
	  bp_locations.push_back(btVector3(x,y,z));
	  if (COMMENTS)
	    {
	      cout << "Made object " << index << endl;
	      cout << "b_index: " << b_index[index] << endl;
	    }
	  //Create hinge between the two
	  //but first set  axis vars
	  //or maybe not
	  
	  // CreateHinge(j_index, b_index[base_index], b_index[index], btVector3(j_x,j_y,j_z), btVector3(a_x,a_y,a_z), joint_l_limits[j_index], joint_u_limits[j_index], joint_motors[j_index]);
	  tb_holder.push_back(j_index);
	  tb_holder.push_back(b_index[base_index]);
	  tb_holder.push_back(b_index[index]);
	  tb_holder.push_back(j_x);
	  tb_holder.push_back(j_y);
	  tb_holder.push_back(j_z);
	  tb_holder.push_back(a_x);
	  tb_holder.push_back(a_y);
	  tb_holder.push_back(a_z);
	  tb_holder.push_back(joint_l_limits[j_index]);
	  tb_holder.push_back(joint_u_limits[j_index]);
	  tb_holder.push_back(joint_motors[j_index]);
	  hinges_to_build.push_back(tb_holder);
	  tb_holder.clear();
	  built_joints.push_back(j_index);
	  used_joints[index]++;
	  used_joints[base_index]++;
	  if (COMMENTS)
	    {
	      cout << "Made hinge between " << base_index << " and " << index << " using joint " << j_index << endl;
	      cout << "b_index: " << b_index[index] << " base_b_index: " << b_index[base_index] << endl;
	    }
	  
	  //Recalculate indexes 
	  j_index ++;
	  if (j_index >= joint_indexs.size())
	    { if (COMMENTS)
		{cout << "Ran out of joints!" << endl;}
	      t_acc = body_indexs.size();
	      break;}
	  base_index = index; 	  
	  index++;
	  b_acc++;
	  //can't set next b_index now, because it's unclear if the next index used will be the next index just iterated to.
	}
      
      
      // if index doesn't have joint locs, try from start next
      else if (used_joints[index] >= body_j_nums[index])
	{
	  index=0;
	  //if it has been built/tossed, or if it has run out of joint locs, pick the next one instead
	  while (built_body[index]==1 || tossed_bodys[index]==1 || used_joints[index]>=body_j_nums[index])
	    {
	      index++;
	      // if we reach the end of the list, we're out of parts to build
	      if (index >= body_indexs.size())
		{ if (COMMENTS)
		    {cout << "Reached the last usuable part" << endl;}
		  t_acc = body_indexs.size();
		  break;}
	    }
	  if (COMMENTS)
	    {cout << "Try new index " << index << endl;}
	}
      
      // else: base_index doesn't have joint locs, so try next
      else if (used_joints[base_index] >= body_j_nums[base_index])
	{
	  base_index++;
	  bool looped = false;
	  //(if it hasn't been built or while it has been tossed) or if it has run out of joints locs, check the next one
	  while (built_body[base_index]==0 || tossed_bodys[base_index]==1 || used_joints[base_index]>=body_j_nums[base_index])
	    {
	      base_index++;
	      if (base_index >= body_indexs.size() && looped)
		{ if (COMMENTS)
		    {cout << "Reached the last usable base" << endl;}
		  t_acc = body_indexs.size();
		  break;}
	      if (base_index >= body_indexs.size())
		{base_index=0;
		  looped = true;}
	    }
	  if (COMMENTS)
	    {cout << "Try next base_index " << base_index << endl;}
	}
      
      else 
	{
	  if (COMMENTS)
	    {cout << "Got to end: " << used_joints[base_index] << '|' << body_j_nums[base_index] << endl;}
	}
    } while (bp_locations.size() < (body_indexs.size()-t_acc));

  
  //======================= Build The Body ===============================
  
  // Holds the maximum offset need to make the body start above the ground.
  btScalar vert_offset = 0;
  bool use_offset = false;
  /* 
  for (int i=0; i<parts_to_build.size(); i++)
    {
      vert_offset = min(parts_to_build[i][2] - parts_to_build[i][4], vert_offset);
    }

  if (COMMENTS)
    {cout << "Offset needed: " << vert_offset << endl;}

  if (vert_offset < 0)
    {
      vert_offset = -1*vert_offset;
      if (COMMENTS)
	{cout << "Offset used: " << vert_offset << endl;}
      for (int i=0; i<parts_to_build.size(); i++)
	{
	  parts_to_build[i][2] = parts_to_build[i][2] + vert_offset;
	}
      for (int i=0; i<hinges_to_build.size(); i++)
	{
	  hinges_to_build[i][4] = hinges_to_build[i][4] + vert_offset;
	}
    }
    `*/
    
  if (COMMENTS)
    {cout << "Done with body setup, start bulding" << endl;}

  for (int i=0; i<parts_to_build.size(); i++)
    {
      cout << "Gone through " << i << " times." << endl;
      if (i==0)
	{
	  CreateSphere(parts_to_build[i][0], parts_to_build[i][1], parts_to_build[i][2], parts_to_build[i][3], parts_to_build[i][4]);
	}
      else
	{
	  int i_h = i-1; 
	  CreateSphere(parts_to_build[i][0], parts_to_build[i][1], parts_to_build[i][2], parts_to_build[i][3], parts_to_build[i][4]);
	  CreateHinge(hinges_to_build[i_h][0], hinges_to_build[i_h][1], hinges_to_build[i_h][2], hinges_to_build[i_h][3], hinges_to_build[i_h][4], hinges_to_build[i_h][5], hinges_to_build[i_h][6], hinges_to_build[i_h][7], hinges_to_build[i_h][8], hinges_to_build[i_h][9], hinges_to_build[i_h][10], hinges_to_build[i_h][11]);
	}
    }
  
  if (COMMENTS)
    {cout << "Done with body building, start sensor and neurons" << endl;}

  //=============== Build Sensors and Neurons===========================================
  vector<int> used_s_mounts(body_indexs.size(), 0);
  vector<int> used_n_mounts(body_indexs.size(), 0);
  
  vector<int> v_holder;

  int s_index = 0;
  int n_index = 0;
  
  int sensor_capacity = 0;
  int neuron_capacity = 0;
  //Calculate total sensor and neuron mount slots
  for (int i=0; i<body_indexs.size(); i++)
    {
      if (built_body[i]==1)
	{
	  sensor_capacity += body_s_nums[i];
	  neuron_capacity += body_n_nums[i];
	}
    }    

  int sensor_total = sensor_indexs.size();
  int neuron_total = neuron_indexs.size();

  // While all sensors aren't built and all slots aren't taken up
  while ((built_sensors.size() < sensor_total) && (built_sensors.size() < sensor_capacity))
  // For all potential parts
    {
      for (int i=0; i<body_indexs.size(); i++)
	{
	  // Add sensors to built parts
	  if (built_body[i]==1)
	    {
	      // if part has free mounts for it
	      if ((body_s_nums[i] - used_s_mounts[i]) > 0)
		{
		  v_holder.push_back(s_index);
		  v_holder.push_back(i);
		  built_sensors.push_back(v_holder);
		  if ((built_sensors.size()==sensor_total) || (built_sensors.size()==sensor_capacity))
		    { v_holder.clear();
		      break;}
		  v_holder.clear();
		  s_index++;
		}
	    }
	}    
    }

  while ((built_neurons.size() < neuron_total) && (built_neurons.size() < neuron_capacity))
    {
      for (int i=0; i<body_indexs.size(); i++)
	{
	  if (built_body[i]==1)
	    {
	      if ((body_n_nums[i] - used_n_mounts[i]) > 0)
		{
		  v_holder.push_back(n_index);
		  v_holder.push_back(i);
		  built_neurons.push_back(v_holder);
		  if ((built_neurons.size()==neuron_total) || (built_neurons.size()==neuron_capacity))
		    { v_holder.clear();
		      break;}
		  v_holder.clear();
		  n_index++;
		}
	    }
	}
    }     

  if (COMMENTS)
    {
      cout << endl << built_sensors.size() << " Sensors!" << endl << endl;
      
      for (int i=0; i<built_sensors.size(); i++)
	{
	  cout << built_sensors[i][0] << ',' << built_sensors[i][1] << endl;
	}
      
      cout << endl << built_neurons.size() << " Neurons!" << endl << endl;
      
      for (int i=0; i<built_neurons.size(); i++)
	{
	  cout << built_neurons[i][0] << ',' << built_neurons[i][1] << endl;
	}
    }

	
	 
  //====================== Build Wires ===========================================

  // use same index that "built_" lists do
  vector<int> used_s_outputs(built_sensors.size(), 0);
  vector<int> used_n_inputs(built_neurons.size(), 0);
  vector<int> used_n_outputs(built_neurons.size(), 0);
  vector<int> used_j_inputs(built_joints.size(), 0);

  // uses same index that "built_" lists do
  vector<int> tossed_sensors(built_sensors.size(), 0);
  vector<int> tossed_neurons(built_neurons.size(), 0);
  
  int wire_total = wire_indexs.size();
  int output_total = 0;
  int output_s_total = 0;
  int output_n_total = 0;
  for (int i=0; i<built_sensors.size(); i++)
    {
      output_s_total += sensor_outputs[built_sensors[i][0]];
    }
  for (int i=0; i<built_neurons.size(); i++)
    {
      output_n_total += neuron_outputs[built_neurons[i][0]];
    }

  output_total = output_s_total + output_n_total;

  int input_total = 0;
  int input_j_total = 0;
  int input_n_total = 0;
  for (int i=0; i<built_joints.size(); i++)
    {
      input_j_total += joint_inputs[built_joints[i]];
    }
  for (int i=0; i<built_neurons.size(); i++)
    {
      input_n_total += neuron_inputs[built_neurons[i][0]];
    }
  input_total = input_j_total + input_n_total;
  
  j_index = 0;
  s_index = 0; 
  n_index = 0;
  int s_global = 0;
  int n_global = 0;
  int w_index = 0;
  
  // false means from_neuron
  bool from_sensor = true;
  // false means to_neuron
  bool to_joint = wire_directs[0];

  bool found_joint = true;
  bool found_neuron = true;
  v_holder.clear();
  
  if (COMMENTS)
    {
      cout << endl;
      cout << "Wires Total: " << wire_total << endl;
      cout << "Joint Inputs: " << input_j_total << endl;
      cout << "Used Joint Inputs: " << used_part_counter(used_j_inputs) << endl; 
      cout << "Neuron Inputs: " << input_n_total << endl;
      cout << "Used Neuron Inputs: " << used_part_counter(used_n_inputs) << endl;
      cout << "Sensor Ouputs: " << output_s_total << endl;
      cout << "Used Sensor Outputs: " << used_part_counter(used_s_outputs) << endl;
      cout << "Neuron Ouputs: " << output_n_total << endl;
      cout << "Used Neuron Outputs: " << used_part_counter(used_n_outputs) << endl;  
    }
  // Build Wires
  // While unused wire parts, and some combo of open outputs and inputs
  while ((wire_total > (built_s_wires.size()+built_n_wires.size()))&&
	 ((input_total > (used_part_counter(used_n_inputs) + used_part_counter(used_j_inputs)))&&
	  (output_total > (used_part_counter(used_s_outputs) + used_part_counter(used_n_outputs))))&&
	 (w_index < wire_total))
    {
      if (COMMENTS)
	{
	  cout << endl;
	}
      // sensor iteraton
      if (from_sensor)
	{
	  // for each sensor
	  for (int i=0; i < built_sensors.size(); i++)
	    {
	      // global index of built sensor
	      s_global = built_sensors[i][0];
	      // if it has free outputs, build a wire from it
	      if (sensor_outputs[s_global] > used_s_outputs[i])
		{
		  // if to_joint
		  if (to_joint)
		    {
		      i_hold = j_index;
		      // if not an empty slot in this joint
		      while (!(joint_inputs[built_joints[j_index]] > used_j_inputs[j_index]))
			{
			  // look in others
			  j_index++;
			  // keep looking
			  if (j_index >= built_joints.size())
			    {j_index = 0;}
			  // until you go through once
			  if (j_index == i_hold)
			    { found_joint = false;
			      break;}
			}
		      // If you find a good joint
		      if (found_joint)
			{
			  // set up wire
			  v_holder.push_back(w_index);
			  v_holder.push_back(s_global);
			  v_holder.push_back(built_joints[j_index]);
			  v_holder.push_back(0);
			  // build it
			  built_s_wires.push_back(v_holder);
			  if (COMMENTS)
			    {cout << "Built Wire--SJa: " << v_holder[0] << endl;}
			  used_j_inputs[j_index]++;
			  j_index++;
			  if (j_index >= built_joints.size())
			    {j_index = 0;}
			}
		     
		      // If you don't find a good joint
		      else  
			{
			  i_hold = n_index;
			  // look for a good neuron
			  while (!(neuron_inputs[built_neurons[n_index][0]] > used_n_inputs[n_index]))
			    {
			      n_index++;
			      if (n_index >= built_neurons.size())
				{n_index = 0;}
			      if (n_index==i_hold)
				{ found_neuron = false;
				  break;}
			    }
			  // If you find a good neuron
			  if (found_neuron)
			    {
			      // set up wire
			      v_holder.push_back(w_index);
			      v_holder.push_back(s_global);
			      v_holder.push_back(built_neurons[n_index][0]);
			      v_holder.push_back(1);
			      // build it
			      built_s_wires.push_back(v_holder);
			      if (COMMENTS)
				{cout << "Built Wire--SNb: " << v_holder[0] << endl;}
			      used_n_inputs[n_index]++;
			      n_index++;
			      if (n_index >= built_neurons.size())
				{n_index=0;}
			    }
			}
		      // and get ready for next step
		      if (found_joint||found_neuron)
			{
			  if (COMMENTS)
			    {cout << "test--SJ" << endl;}
			  v_holder.clear();
			  used_s_outputs[i]++;
			  w_index++;
			  if (w_index >= wire_total)
			    {break;}
			  to_joint = wire_directs[w_index];
			}
		      else 
			{
			  found_joint = true;
			  found_neuron = true;
			  if (COMMENTS)
			    {cout << "Nothing on this run vSJ" << endl;}
			}
		    }
		  // Or you look for a neuron first
		  else
		    {
		      i_hold = n_index;
		      // look for a good neuron
		      while (!(neuron_inputs[built_neurons[n_index][0]] > used_n_inputs[n_index]))
			{
			  n_index++;
			  if (n_index >= built_neurons.size())
			    {n_index = 0;}
			  if (n_index==i_hold)
			    { found_neuron = false;
			      break;}
			}
		      // If you find a good neuron
		      if (found_neuron)
			{
			  // set up wire
			  v_holder.push_back(w_index);
			  v_holder.push_back(s_global);
			  v_holder.push_back(built_neurons[n_index][0]);
			  v_holder.push_back(1);
			  // build it
			  built_s_wires.push_back(v_holder);
			  if (COMMENTS)
			    {cout << "Built Wire--SNa: " << v_holder[0] << endl;}
			  used_n_inputs[n_index]++;
			  n_index++;
			  if (n_index >= built_neurons.size())
			    {n_index=0;}
			}
		      // If you don't find a good neuron
		      else 
			{
			  // look for a joint instead
			  i_hold = j_index;
			  // if not an empty slot in this joint
			  while (!(joint_inputs[built_joints[j_index]] > used_j_inputs[j_index]))
			    {
			      // look in others
			      j_index++;
			      // keep looking
			      if (j_index >= built_joints.size())
				{j_index = 0;}
			      // until you go through once
			      if (j_index == i_hold)
				{ found_joint = false;
				  break;}
			    }
			  // If you find a good joint
			  if (found_joint)
			    {
			      // set up wire
			      v_holder.push_back(w_index);
			      v_holder.push_back(s_global);
			      v_holder.push_back(built_joints[j_index]);
			      v_holder.push_back(0);
			      // build it
			      built_s_wires.push_back(v_holder);
			      if (COMMENTS)
				{cout << "Built Wire--SJb: " << v_holder[0] << endl;}
			      used_j_inputs[j_index]++;
			      j_index++;
			      if (j_index >= built_joints.size())
				{j_index = 0;}
			    }
			}
		      
		      // and get ready for next step
		      if (found_joint||found_neuron)
			{
			  if (COMMENTS)
			    {cout << "test--SN" << endl;}
			  v_holder.clear();
			  used_s_outputs[i]++;
			  w_index++;
			  if (w_index >= wire_total)
			    {break;}
			  to_joint = wire_directs[w_index];
			}
		      else 
			{
			  found_joint = true;
			  found_neuron = true;
			  if (COMMENTS)
			    {cout << "Nothing on this run vSN" << endl;}
			}
		    }
		}
	    }
	  from_sensor = false;
	}
      // else neuron iteration
      else if (!from_sensor)
	{
	  // Go through all built neurons
	  for (int i=0; i < built_neurons.size(); i++)
	    {
	      // global index of built neuron
	      n_global = built_neurons[i][0];
	      //if it has free outputs, build a wire from it
	      if (neuron_outputs[n_global] > used_n_outputs[i])
		{
		  // if to_joint
		  if (to_joint)
		    {
		      i_hold = j_index;
		      // if not an empty slot in this joint
		      while (!(joint_inputs[built_joints[j_index]] > used_j_inputs[j_index]))
			{
			  // look in others
			  j_index++;
			  // keep looking
			  if (j_index >= built_joints.size())
			    {j_index = 0;}
			  // until you go through once
			  if (j_index == i_hold)
			    { found_joint = false;
			      break;}
			}
		      // If you find a good joint
		      if (found_joint)
			{
			  // set up wire
			  v_holder.push_back(w_index);
			  v_holder.push_back(n_global);
			  v_holder.push_back(built_joints[j_index]);
			  v_holder.push_back(0);
			  // build it
			  built_s_wires.push_back(v_holder);
			  if (COMMENTS)
			    {cout << "Built Wire--NJa: " << v_holder[0] << endl;}
			  used_j_inputs[j_index]++;
			  j_index++;
			  if (j_index >= built_joints.size())
			    {j_index = 0;}
			}
		      // If you don't find a good joint
		      else  
			{
			  i_hold = n_index;
			  // look for a good neuron
			  while (!(neuron_inputs[built_neurons[n_index][0]] > used_n_inputs[n_index]))
			    {
			      n_index++;
			      if (n_index >= built_neurons.size())
				{n_index = 0;}
			      if (n_index==i_hold)
				{ found_neuron = false;
				  break;}
			    }
			  // If you find a good neuron
			  if (found_neuron)
			    {
			      // set up wire
			      v_holder.push_back(w_index);
			      v_holder.push_back(n_global);
			      v_holder.push_back(built_neurons[n_index][0]);
			      v_holder.push_back(1);
			      // build it
			      built_s_wires.push_back(v_holder);
			      if (COMMENTS)
				{cout << "Built Wire--NNb " << v_holder[0] << endl;}
			      used_n_inputs[n_index]++;
			      n_index++;
			      if (n_index >= built_neurons.size())
				{n_index=0;}
			    }
			}
		      // and get ready for next step
		      if (found_joint||found_neuron)
			{
			  if (COMMENTS)
			    {cout << "test--NJ" << endl;}
			  v_holder.clear();
			  used_n_outputs[i]++;
			  w_index++;
			  if (w_index >= wire_total)
			    {break;}
			  to_joint = wire_directs[w_index];
			}
		      else 
			{
			  found_joint = true;
			  found_neuron = true;
			  if (COMMENTS)
			    {cout << "Nothing on this run vNJ" << endl;}
			}
		    }
		  // Or you look for a neuron first
		  else //this
		    {
		      i_hold = n_index;
		      // look for a good neuron
		      while (!(neuron_inputs[built_neurons[n_index][0]] > used_n_inputs[n_index]))
			{
			  n_index++;
			  if (n_index >= built_neurons.size())
			    {n_index = 0;}
			  if (n_index==i_hold)
			    { found_neuron = false;
			      break;}
			}
		      // If you find a good neuron
		      if (found_neuron)
			{
			  // set up wire
			  v_holder.push_back(w_index);
			  v_holder.push_back(n_global);
			  v_holder.push_back(built_neurons[n_index][0]);
			  v_holder.push_back(1);
			  // build it
			  built_s_wires.push_back(v_holder);
			  if (COMMENTS)
			    {cout << "Built Wire--NNa: " << v_holder[0] << endl;}
			  used_n_inputs[n_index]++;
			  n_index++;
			  if (n_index >= built_neurons.size())
			    {n_index=0;}
			}
		      // If you don't find a good neuron
		      else  
			{
			  // look for a joint instead
			  i_hold = j_index;
			  // if not an empty slot in this joint
			  while (!(joint_inputs[built_joints[j_index]] > used_j_inputs[j_index]))
			    {
			      // look in others
			      j_index++;
			      // keep looking
			      if (j_index >= built_joints.size())
				{j_index = 0;}
			      // until you go through once
			      if (j_index == i_hold)
				{ found_joint = false;
				  break;}
			    }
			  // If you find a good joint
			  if (found_joint)
			    {
			      // set up wire
			      v_holder.push_back(w_index);
			      v_holder.push_back(n_global);
			      v_holder.push_back(built_joints[j_index]);
			      v_holder.push_back(0);
			      // build it
			      built_s_wires.push_back(v_holder);
			      if (COMMENTS)
				{cout << "Built Wire--NJb " << v_holder[0] << endl;}
			      used_j_inputs[j_index]++;
			      j_index++;
			      if (j_index >= built_joints.size())
				{j_index = 0;}
			    }
			}
		      // and get ready for next step
		      if (found_joint||found_neuron)
			{
			  if (COMMENTS)
			    {cout << "test--NN" << endl;}
			  v_holder.clear();
			  used_n_outputs[i]++;
			  w_index++;
			  if (w_index >= wire_total)
			    {break;}
			  to_joint = wire_directs[w_index];
			}
		      else 
			{
			  found_joint = true;
			  found_neuron = true;
			  if (COMMENTS)
			    {cout << "Nothing on this run vNN" << endl;}
			}
		    }
		}
	    }
	  from_sensor = true;
	}
    }

  if (COMMENTS)
    {
      cout << endl << built_s_wires.size() << " Wires from Sensors" << endl << endl;
      
      for (int i=0; i<built_s_wires.size(); i++)
	{
	  for (int j=0; j<built_s_wires[i].size(); j++)
	    {
	      cout << built_s_wires[i][j] << ',';
	    }
	  cout << endl;
	}
      
      cout << endl << built_n_wires.size() << " Wires from Neurons" << endl << endl;
      
      for (int i=0; i<built_n_wires.size(); i++)
	{
	  for (int j=0; j<built_n_wires[i].size(); j++)
	    {
	      cout << built_n_wires[i][j] << ',';
	    }
	  cout << endl;
	}
    }

   //========================== Build Wire Matrices ========================================
   
   d_hold = 0;
   vector<long double> dv_holder;
   
   // From sensor to joints
   for(int i=0;i<built_sensors.size();i++)
     {
       for(int j=0;j<built_joints.size();j++)
	 {
	   for(int k=0;k<built_s_wires.size();k++)
	     {
	       if ((built_s_wires[k][1]==built_sensors[i][0])&&// comes from sensor i
		   (built_s_wires[k][2]==built_joints[j])&&// goes to joint j
		   (built_s_wires[k][3]==0)) //wire goes to joints
		 {
		   d_hold += wire_weights[built_s_wires[k][0]];
		 }
	     }
	   dv_holder.push_back(d_hold);
	   d_hold = 0;
	 }
       weights_s2j.push_back(dv_holder);
       dv_holder.clear();
     }
   // From neurons to joints
   for(int i=0;i<built_neurons.size();i++)
     {
       for(int j=0;j<built_joints.size();j++)
	 {
	   for(int k=0;k<built_n_wires.size();k++)
	     {
	       if ((built_n_wires[k][1]==built_neurons[i][0])&&// comes from neuron i
		   (built_n_wires[k][2]==built_joints[j])&&// goes to joint j
		   (built_n_wires[k][3]==0)) //wire goes to joints
		 {
		   d_hold += wire_weights[built_n_wires[k][0]];
		 }
	     }
	   dv_holder.push_back(d_hold);
	   d_hold = 0;
	 }
       weights_n2j.push_back(dv_holder);
       dv_holder.clear();
     }
   // From sensors to neurons
    for(int i=0;i<built_sensors.size();i++)
     {
       for(int j=0;j<built_neurons.size();j++)
	 {
	   for(int k=0;k<built_s_wires.size();k++)
	     {
	       if ((built_s_wires[k][1]==built_sensors[i][0])&&// comes from sensor i
		   (built_s_wires[k][2]==built_neurons[j][0])&&// goes to neuron j
		   (built_s_wires[k][3]==1)) //wire goes to neurons
		 {
		   d_hold += wire_weights[built_s_wires[k][0]];
		 }
	     }
	   dv_holder.push_back(d_hold);
	   d_hold = 0;
	 }
       weights_s2n.push_back(dv_holder);
       dv_holder.clear();
     }
    // From neurons to neurons
     for(int i=0;i<built_neurons.size();i++)
     {
       for(int j=0;j<built_neurons.size();j++)
	 {
	   for(int k=0;k<built_n_wires.size();k++)
	     {
	       if ((built_n_wires[k][1]==built_neurons[i][0])&&// comes from neuron i
		   (built_n_wires[k][2]==built_neurons[j][0])&&// goes to neuron j
		   (built_n_wires[k][3]==1)) //wire goes to neurons
		 {
		   d_hold += wire_weights[built_n_wires[k][0]];
		 }
	     }
	   dv_holder.push_back(d_hold);
	   d_hold = 0;
	 }
       weights_n2n.push_back(dv_holder);
       dv_holder.clear();
     }
		
     if (COMMENTS)
       {
	 cout << "Sensor to Joint Weights" << endl;
	 for(int i=0;i<built_sensors.size();i++)
	   {
	     for (int j=0;j<built_joints.size();j++)
	       {
		 cout << weights_s2j[i][j] << ", ";
	       }
	     cout << endl;
	   }
	 cout << endl;
	 
	 cout << "Neuron to Joints Weights" << endl;
	 for(int i=0;i<built_neurons.size();i++)
	   {
	     for (int j=0;j<built_joints.size();j++)
	       {
		 cout << weights_n2j[i][j] << ", ";
	       }
	     cout << endl;
	   }
	 cout << endl;
	 
	 cout << "Sensor to Neuron Weights" << endl;
	 for(int i=0;i<built_sensors.size();i++)
	   {
	     for (int j=0;j<built_neurons.size();j++)
	       {
		 cout << weights_s2n[i][j] << ", ";
	       }
	     cout << endl;
	   }
	 cout << endl;
	 
	 cout << "Neuron to Neuron Weights" << endl;
	 for(int i=0;i<built_neurons.size();i++)
	   {
	     for (int j=0;j<built_neurons.size();j++)
	       {
		 cout << weights_n2n[i][j] << ", ";
	       }
	     cout << endl;
	   }
	 cout << endl;
       }
     
     //pause = true;
}


// Set-up GUI for step-simulation 
void BasicWorld::clientMoveAndDisplay ()
{
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  
  //simple dynamics world doesn't handle fixed-time-stepping
  float ms = getDeltaTimeMicroseconds();
  
  float minFPS = 90000.f/60.f;

  if (ms > minFPS)
    ms = minFPS;
		
  // ================== Stepping through the world ====================
  if(m_dynamicsWorld)
    {
      if (!pause || (pause && oneStep))
	{
	  //reset touches 
	  for (int i=0;i<touches.size();i++)
	    {
	      touches[i] = 0;
	    }
	  
	  m_dynamicsWorld->stepSimulation(ms/90000.f);
	  
	  /*
	  for (int i=0;i<touches.size();i++)
	    {
	      cout << touches[i] << ", ";
	    }
	  cout << endl;
	  */
       

	  // offset by 1 b/c touches[0] is ground
	  // and reverse order b/c that's how matrix multiplication works
	
	  // First do Sensor to Neurons
	  for (int j=0;j<built_neurons.size();j++)
	    {
	      for (int i=0;i<built_sensors.size();i++)
		{
		  d_hold += touches[built_sensors[i][0]+1] * weights_s2n[i][j];
		}
	      output_s2n.push_back(d_hold);
	      d_hold = 0;
	    }
	  // Second is Neurons to Neurons
	  for (int j=0;j<built_neurons.size();j++)
	    {
	      for (int i=0;i<output_s2n.size();i++)
		{
		  d_hold += output_s2n[i] * weights_n2n[i][j];
		}
	      output_n2n.push_back(d_hold);
	      d_hold = 0;
	    }
	  // Third is Sensors to Joints
	   for (int j=0;j<built_joints.size();j++)
	    {
	      for (int i=0;i<built_sensors.size();i++)
		{
		  d_hold += touches[built_sensors[i][0]+1] * weights_s2j[i][j];
		}
	      output_s2j.push_back(d_hold);
	      d_hold = 0;
	    }
	  // Last is Neurons to Joint
	   for (int j=0;j<built_joints.size();j++)
	     {
	       for (int i=0;i<built_neurons.size();i++)
		 {
		   d_hold += output_n2n[i] * weights_n2j[i][j];
		 }
	       output_n2j.push_back(d_hold);
	       d_hold = 0;
	     }	 
	   // Combine both outputs and actuate joints
	   for (int i=0;i<built_joints.size();i++)
	     {
	       motor_command = output_s2j[i] + output_n2j[i];
	       motor_command = (2/1+exp(-motor_command))-1;
	       motor_command = motor_command*360;
	       //cout << motor_command << ", ";
	       ActuateJoint(built_joints[i], motor_command, ms/90000.f);
	     }
	   //cout << endl;
	   //clear holders
	   output_s2n.clear();
	   output_n2n.clear();
	   output_s2j.clear();
	   output_n2j.clear();
	   //cout << timeStep << endl;
	   timeStep++;
	    if (timeStep == 300)
		{
		  Save_Position(0);
		  exit(0);
		}

	   
	   oneStep = false;
	}
    }
  
  renderme();
  
  glFlush();
  
  glutSwapBuffers();
}
  
void BasicWorld::displayCallback()
{
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); 

  renderme();

  glFlush();
  
  glutSwapBuffers();
}


void BasicWorld::keyboardCallback(unsigned char key, int x, int y)
{
  switch (key)
    {
    case 'p':
      {
	pause = (!pause);
      }
    case 's':
      {
	oneStep = true;
      }
    default:
      {
      DemoApplication::keyboardCallback(key, x, y);
      }
    }
}

// =================== Clean up Stage ===============================
void BasicWorld::exitPhysics()
{
 
  // Rigid Bodies
  // m_dynamicsWorld->removeRigidBody(fallRigidBody);
  //delete fallRigidBody->getMotionState();
  //delete fallRigidBody;

  //m_dynamicsWorld->removeRigidBody(groundRigidBody);
  //delete groundRigidBody->getMotionState();
  //delete groundRigidBody;
  
  // for my jointparts
  for (int i=0;i<m_jointparts.size();i++)
    {
      DestroyHinge(i);
    }

  // for my bodyparts
  for (int i=0;i<m_geomparts.size();i++)
    {
      DeleteObject(i);
    }

  //remove the rigidbodies from the dynamics world and delete them
  for (int i=m_dynamicsWorld->getNumCollisionObjects()-1; i>=0 ;i--)
    {
      btCollisionObject* obj = m_dynamicsWorld->getCollisionObjectArray()[i];
      btRigidBody* body = btRigidBody::upcast(obj);
      if (body && body->getMotionState())
	{
	  delete body->getMotionState();
	}
      m_dynamicsWorld->removeCollisionObject( obj );
      delete obj;
    }


  // World
  delete m_dynamicsWorld;
  delete m_solver;
  delete m_dispatcher;
  delete m_collisionConfiguration;
  delete m_broadphase;

}




