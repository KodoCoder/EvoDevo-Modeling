"""
These are not unit-tests per se, as the input of some functions are the
output of other functions.  With this is mind, the tests are ordered to
reflect the order of dependency; that is, tests of dependent function come
after the tests of functions they depend on.
"""
import itertools
import pytest

from evodevo.my_table import table
import evodevo.part as edpart


def dec2quat(num):
    """Converts an integer <64 to a quaternary string"""
    if num < 64:
        char1 = num / 16
        num -= 16 * char1
        char2 = num / 4
        num -= 4 * char2
        quat = ''.join((str(char1), str(char2), str(num)))
        return quat
    else:
        raise KeyError


@pytest.fixture(scope='module')
def empty_part():
    """
    This part has no codons except for the start and stop codon.
    """
    return edpart.Part('122222')


@pytest.fixture(scope='module')
def one_of_each_part():
    """
    This part has one of each codon.
    """
    gene_seq = '122'
    for i in sorted(iter(table)):
        if i != '122' or i != '222':
            gene_seq = ''.join((gene_seq, i))
    gene_seq = ''.join((gene_seq, '222'))
    return edpart.Part(gene_seq)


@pytest.fixture(scope='module')
def eight_of_eight_parts():
    """
    A list of parts with eight of eight types of codons.
    """
    ret = list()
    gene_seq = '122'
    for c, i in enumerate(sorted(iter(table))):
        if (c+1) % 8 != 0:
            gene_seq = ''.join((gene_seq, i*8))
        else:
            gene_seq = ''.join((gene_seq, i*8, '222'))
            ret.append(edpart.Part(gene_seq))
            gene_seq = '122'
    return ret


@pytest.fixture(scope='module')
def diffusion_part():
    """
    A part with 20 of each regulatory_element
    """
    gene_seq = '122'
    for i in sorted(set(table.iteritems())):
        if i[1][1] == 'R' and (i[1] not in
                               [table[gene_seq[j:j+3]] for j in
                                xrange(0, len(gene_seq), 3)]):
            gene_seq = ''.join((gene_seq, i[0]*10))
    gene_seq = ''.join((gene_seq, '222'))
    diff_part = edpart.Part(gene_seq)
    diff_part._update()
    diff_part._update()
    return diff_part


def test_init(empty_part, one_of_each_part, eight_of_eight_parts):
    """
    Also tests _init_re_codons(), _calculate_capacity(), _count_regulators()
    """
    for i in empty_part.__dict__.iteritems():
        try:
            n = len(i[1])
            if i[0] != 'gene_sequence':
                assert i[1] == [0] * n
        except TypeError:
            if i[0] == 'other_codons':
                assert i[1] == 2
            else:
                assert i[1] == 0
    for i in one_of_each_part.__dict__.iteritems():
        try:
            n = len(i[1])
            if i[0] == 'gene_sequence':
                pass
            elif i[0][:3] != 'reg':
                if i[0][-4:] == '_num' or i[0][-4:] == 'puts':
                    assert i[1] == [2, 1]
                else:
                    assert i[1] == [1] * n
            else:
                assert i[1] == [0] * n
        except TypeError:
            if i[0] == 'capacity':
                assert i[1] == 630
            elif i[0] == 'regulators_per_update':
                assert i[1] == 47
            elif i[0] == 'other_codons':
                assert i[1] == 19
            elif i[0][:2] == 'rc':
                assert i[1] == 1
            else:
                i[1] == 0
    for i in eight_of_eight_parts[0].__dict__.iteritems():
        print i
        try:
            n = len(i[1])
            if i[0] == 'gene_sequence':
                pass
            elif i[0] == 'codon_s_num':
                assert i[1] == [16, 8]
            elif i[0] == 'codon_size':
                assert i[1] == [8, 8]
            elif i[0] == 'codon_j_num':
                assert i[1] == [0, 8]
            else:
                assert i[1] == [0] * n
        except TypeError:
            if i[0] == 'other_codons':
                assert i[1] == 18
            elif i[0] == 'regulators_per_update':
                assert i[1] == 48
            else:
                assert i[1] == 0


def test_eq(empty_part, one_of_each_part, eight_of_eight_parts):
    assert empty_part == empty_part
    assert empty_part != one_of_each_part
    assert one_of_each_part == one_of_each_part
    for part in eight_of_eight_parts:
        assert part == part
        assert part != empty_part
        assert part != one_of_each_part


def test_get_push_list(empty_part, diffusion_part):
    assert edpart.DIFFUSION_RATE_PULL == .1
    assert edpart.DIFFUSION_RATE_PUSH == .05

    edpart.REGULATOR_POOL = [0.] * 40
    # edpart.DIFFUSION_RATE_PUSH = .1
    # edpart.DIFFUSION_RATE_PULL = .05
    for attrib in empty_part.__dict__.iteritems():
        if attrib[0][:4] == 'reg_':
            assert attrib[1] == [0] * len(attrib[1])
    assert [0] * 40 == empty_part.get_push_list() == edpart.REGULATOR_POOL
    for attrib in empty_part.__dict__.iteritems():
        if attrib[0][:4] == 'reg_':
            assert attrib[1] == [0] * len(attrib[1])

    for attrib in diffusion_part.__dict__.iteritems():
        if attrib[0][:4] == 'reg_':
            assert attrib[1] == [20] * len(attrib[1])
    assert [1] * 40 == diffusion_part.get_push_list()
    for attrib in diffusion_part.__dict__.iteritems():
        if attrib[0][:4] == 'reg_':
            assert attrib[1] == [20] * len(attrib[1])

    assert [1] * 40 == edpart.REGULATOR_POOL


def test_get_pull_list(empty_part, diffusion_part):
    assert edpart.DIFFUSION_RATE_PULL == .1
    assert edpart.DIFFUSION_RATE_PUSH == .05

    edpart.REGULATOR_POOL = [11] * 40
    for attrib in empty_part.__dict__.iteritems():
        if attrib[0][:4] == 'reg_':
            assert attrib[1] == [0] * len(attrib[1])
    assert [1] * 40 == empty_part.get_pull_list()
    for attrib in empty_part.__dict__.iteritems():
        if attrib[0][:4] == 'reg_':
            assert attrib[1] == [0] * len(attrib[1])

    assert [10] * 40 == edpart.REGULATOR_POOL

    for attrib in diffusion_part.__dict__.iteritems():
        if attrib[0][:4] == 'reg_':
            assert attrib[1] == [20] * len(attrib[1])
    assert [1] * 40 == diffusion_part.get_pull_list()
    for attrib in diffusion_part.__dict__.iteritems():
        if attrib[0][:4] == 'reg_':
            assert attrib[1] == [20] * len(attrib[1])

    assert [9] * 40 == edpart.REGULATOR_POOL
    assert ([0] * 40 == empty_part.get_pull_list() ==
            diffusion_part.get_pull_list())


def tets_use_phpl_list(empty_part, diffusion_part):
    assert edpart.DIFFUSION_RATE_PULL == .1
    assert edpart.DIFFUSION_RATE_PUSH == .05

    edpart.REGULATOR_POOL = [0] * 40
    for attrib in diffusion_part.__dict__.iteritems():
        if attrib[0][:4] == 'reg_':
            assert attrib[1] == [20] * len(attrib[1])
    phlist = diffusion_part.get_push_list()
    pllist = diffusion_part.get_pull_list()
    phpllst = [i - j for i, j in
               itertools.izip(phlist, pllist)]
    diffusion_part.use_phpl_list(phpllst)
    for attrib in diffusion_part.__dict__.iteritems():
        if attrib[0][:4] == 'reg_':
            assert attrib[1] == [18] * len(attrib[1])
    assert edpart.REGULATOR_POOL == [2] * 40

    edpart.REGULATOR_POOL = [10] * 40
    for attrib in empty_part.__dict__.iteritems():
        if attrib[0][:4] == 'reg_':
            assert attrib[1] == [0] * len(attrib[1])
    phlist = empty_part.get_push_list()
    pllist = empty_part.get_pull_list()
    phpllst = [i - j for i, j in
               itertools.izip(phlist, pllist)]
    for attrib in empty_part.__dict__.iteritems():
        if attrib[0][:4] == 'reg_':
            assert attrib[1] == [1] * len(attrib[1])
    assert edpart.REGULATOR_POOL == [9] * 40


def test_diffusion(empty_part, diffusion_part):
    assert edpart.DIFFUSION_RATE_PULL == .1
    assert edpart.DIFFUSION_RATE_PUSH == .05

    edpart.REGULATOR_POOL = [0] * 40
    for attrib in empty_part.__dict__.iteritems():
        if attrib[0][:4] == 'reg_':
            assert attrib[1] == [0] * len(attrib[1])
    empty_part._diffusion()
    for attrib in empty_part.__dict__.iteritems():
        if attrib[0][:4] == 'reg_':
            assert attrib[1] == [0] * len(attrib[1])

    edpart.REGULATOR_POOL = [20] * 40
    empty_part._diffusion()
    for attrib in empty_part.__dict__.iteritems():
        if attrib[0][:4] == 'reg_':
            print attrib
            assert attrib[1] == [1] * len(attrib[1])
    assert [19] * 40 == edpart.REGULATOR_POOL

    edpart.REGULATOR_POOL = [0] * 40
    for attrib in diffusion_part.__dict__.iteritems():
        if attrib[0][:4] == 'reg_':
            assert attrib[1] == [20] * len(attrib[1])
    diffusion_part._diffusion()
    for attrib in diffusion_part.__dict__.iteritems():
        if attrib[0][:4] == 'reg_':
            assert attrib[1] == [18] * len(attrib[1])
    assert [2] * 40 == edpart.REGULATOR_POOL


def test_update(empty_part, one_of_each_part,
                eight_of_eight_parts, diffusion_part):
    og_empty_part = empty_part
    empty_part._update()
    assert og_empty_part == empty_part

    for attrib in one_of_each_part.__dict__.iteritems():
        if attrib[0][:4] == 'reg_':
            assert attrib[1] == [0] * len(attrib[1])
    one_of_each_part._update()
    for attrib in one_of_each_part.__dict__.iteritems():
        if attrib[0][:4] == 'reg_':
            if(attrib[0][-4:] == '_num' or
               attrib[0][-4:] == 'puts'):
                assert attrib[1] == [2, 1]
            else:
                assert attrib[1] == [1] * len(attrib[1])

    # 8 8s
    pass

    for attrib in diffusion_part.__dict__.iteritems():
        if attrib[0][:4] == 'reg_':
            assert attrib[1] == [20] * len(attrib[1])
    diffusion_part._update()
    for attrib in diffusion_part.__dict__.iteritems():
        if attrib[0][:4] == 'reg_':
            assert attrib[1] == [30] * len(attrib[1])
