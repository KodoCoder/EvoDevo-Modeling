* Blueprint Creation
** Purpose
+ Take a collection of filled proto-parts and determine the values for
  their characteristics.  Then, take those parts and create
  blueprints for constructing the robot. (I.e. put the parts together
  and generate the data needed to create it in Bullet Physics.)
** Use
+ Used after the update_cycles() stage.
+ The functionality of generating characteristics is actually within
  the part.py file. This code builds on that by using those
  characteristics to create a full blueprint.
* Code
#+Name: blueprint_code
#+BEGIN_SRC python :results output replace pp :export both :tangle yes
  # ### Code ###
  from collections import namedtuple
  import copy
  import itertools
  from more_itertools import peekable
  
  from part import Part, BodyPart, JointPart, NeuronPart, SensorPart, WirePart
  
  
  Body = namedtuple('Body', ['body_index', 'mounts_used', 'mounts_total'])
  Joint = namedtuple('Joint', ['joint', 'base_body', 'base_mount', 
                               'other_body'])
  Sensor = namedtuple('Sensor', ['sensor', 'body_index', 'mount_used'])
  Neuron = namedtuple('Neuron', ['neuron', 'body_index', 'mount_used'])
  Wire = namedtuple('Wire', ['wire', 'from_type', 'from_index', 'to_type', 'to_index'])
  Mount = namedtuple('Mount', ['part_index', 'mounts_used', 'mounts_total'])
  
  
  def iterate_mounts_used(ntuple):
      """Returns given namedtuple with its mounts_used value increased by 1.
      
      """
      return ntuple._replace(mounts_used=ntuple.mounts_used+1)
  
  
  def get_frame_parts(parts_built):
      """Returns the bodyparts and the jointparts that will be used for the frame
  
         The returned information also indicates which bodyparts are
         attached to each-other, using which jointparts.
  
      """
      bodypart_list = [i for i in parts_built 
                       if (i.__class__ == BodyPart and
                           i.characteristics.joint_mount_num > 0)]
      unused_bodys = [c for c in enumerate(bodypart_list)]
      used_bodys = []
      joint_list = [i for i in parts_built
                    if i.__class__ == JointPart]
      unused_joints = [c for c in enumerate(joint_list)]
      used_joints = []
      # Get first base_part
      if unused_bodys:
          base_part = Body(body_index=unused_bodys[0][0],
                           mounts_used=0,
                           mounts_total=unused_bodys[0][1].characteristics.joint_mount_num)
          used_bodys.append(base_part)
          unused_bodys.pop(0)
          base_pointer = used_bodys[-1].body_index
      else:
          return [used_bodys, used_joints]
      while True:
          # Get next mounted part
          if unused_bodys:
              mounted_part = Body(body_index=unused_bodys[0][0],
                                  mounts_used=0,
                                  mounts_total=unused_bodys[0][1].characteristics.joint_mount_num)
              used_bodys.append(mounted_part)
              unused_bodys.pop(0)
              mounted_pointer = used_bodys[-1].body_index
          else:
              return [used_bodys, used_joints]
          # Get next joint part
          if unused_joints:
              bi = [i for i in xrange(len(used_bodys))
                    if used_bodys[i].body_index == base_pointer][0]
              joint_part = Joint(joint=unused_joints[0][0],
                                 base_body=base_pointer,
                                 base_mount=used_bodys[bi].mounts_used
                                 other_body=mounted_pointer)
              used_joints.append(joint_part)
              unused_joints.pop(0)
              used_bodys[bi] = iterate_mounts_used(used_bodys[bi])
              used_bodys[-1] = iterate_mounts_used(used_bodys[-1])
              base_pointer = mounted_pointer
          else:
              return [used_bodys[:-1], used_joints]
          # Get next base part
          if used_bodys[-1].mounts_used < used_bodys[-1].mounts_total:
              pass
          else:
              for ind, part in enumerate(used_bodys):
                  if part.mounts_used < part.mounts_total:
                      base_pointer = used_bodys[ind].body_index
                      break
              else:
                  return [used_bodys, used_joints]
  
  
  def mounts_left(mount_list):
      """Returns true if there are unused mounts left in the given list
      
      """
      return any([part.mounts_used < part.mounts_total
                  for part in mount_list])
  
  
  def get_neuron_parts(parts_built, frame_parts):
      """Returns the neurons to be used in the robots ANN.
  
         Even neurons with no input or output slots get put in
         the pool of neuron parts to be used.
      """
      neuron_list = [i for i in parts_built
                     if i.__class__ == NeuronPart]
      unused_neurons = [c for c in enumerate(neuron_list)]
      used_neurons = []
      body_list = [i for i in parts_built
                   if (i.__class__ == BodyPart and
                       i.characteristics.joint_mount_num > 0)]
      neuron_mounts = [Mount(part_index=part.body_index,
                             mounts_used=0,
                             mounts_total=body_list[part.body_index].characteristics.neuron_mount_num)
                       for part in frame_parts[0]]
      for i in itertools.cycle(range(len(neuron_mounts))):
          if unused_neurons and mounts_left(neuron_mounts):
              neuron_part = Neuron(neuron=unused_neurons[0][0],
                                   body_index=neuron_mounts[i].part_index,
                                   mount_used=neuron_mounts[i].mounts_used)
              used_neurons.append(neuron_part)
              unused_neurons.pop(0)   # I think I just need a range(#ofNeuronParts)
              neuron_mounts[i] = iterate_mounts_used(neuron_mounts[i])
          else:
              return used_neurons
  
  
  def get_sensor_parts(parts_built, frame_parts):
      """Returns the sensors to be used in the robots ANN.
      
         Even sensors with no output slots get put in the 
         pool of sensor parts to be used
      """
      sensor_list = [i for i in parts_built
                     if i.__class__ == SensorPart]
      unused_sensors = [c for c in enumerate(sensor_list)]
      used_sensors = []
      body_list = [i for i in parts_built
                   if (i.__class__ == BodyPart and
                       i.characteristics.joint_mount_num > 0)]
      sensor_mounts = [Mount(part_index=part.body_index, 
                             mounts_used=0,
                             mounts_total=body_list[part.body_index].characteristics.sensor_mount_num)
                       for part in frame_parts[0]]
      for i in itertools.cycle(range(len(sensor_mounts))):
          if unused_sensors and mounts_left(sensor_mounts):
              sensor_part = Sensor(sensor=unused_sensors[0][0], 
                                   body_index=sensor_mounts[i].part_index,
                                   mount_used=sensor_mounts[i].mounts_used)
              used_sensors.append(sensor_part)
              unused_sensors.pop(0)  # I think I just need a range(#ofSensorParts)
              sensor_mounts[i] = iterate_mounts_used(sensor_mounts[i])
          else:
              return used_sensors
  
  
  def make_wire_part(part, case, generators):
      """Returns a Wire namedtuple; a wire part to be used.
  
      """
      if case == 'S->J':
          return Wire(wire=part[0],
                      from_type=SensorPart,
                      from_index=generators[3].next(),
                      to_type=JointPart,
                      to_index=generators[0].next())
      elif case == 'S->N':
          return Wire(wire=part[0],
                      from_type=SensorPart,
                      from_index=generators[3].next(),
                      to_type=NeuronPart,
                      to_index=generators[1].next())
      elif case == 'N->J':
          return Wire(wire=part[0],
                      from_type=NeuronPart,
                      from_index=generators[2].next(),
                      to_type=JointPart,
                      to_index=generators[0].next())
      elif case == 'N->N':
          return Wire(wire=part[0],
                      from_type=NeuronPart,
                      from_index=generators[2].next(),
                      to_type=JointPart,
                      to_index=generators[1].next())
      else:
          raise ValueError
  
  
  def get_wire_parts(parts_built, frame_parts, neuron_parts, sensor_parts):
      """Returns the set of wires to be used in bulding the robot.
  
      """
      wire_list = [i for i in parts_built
                   if i.__class__ == WirePart]
      unused_wires = [c for c in enumerate(wire_list)]
      used_wires = []
      joint_list = [i for i in parts_built
                    if i.__class__ == JointPart]
      neuron_list = [i for i in parts_built
                     if i.__class__ == NeuronPart]
      sensor_list = [i for i in parts_built
                     if i.__class__ == SensorPart]
      # Create mount information holders
      joint_ins = [Mount(part_index=part.joint, 
                         mounts_used=0,
                         mounts_total=joint_list[part.joint].characteristics.input_num)
                   for part in frame_parts[1]]
      neuron_ins = [Mount(part_index=part.neuron,
                          mounts_used=0,
                          mounts_total=neuron_list[part.neuron].characteristics.input_num)
                    for part in neuron_parts]
      neuron_outs = [Mount(part_index=part.neuron,
                           mounts_used=0,
                           mounts_total=neuron_list[part.neuron].characteristics.output_num)
                     for part in neuron_parts]
      sensor_outs = [Mount(part_index=part.sensor,
                           mounts_used=0,
                           mounts_total=sensor_list[part.sensor].characteristics.output_num)
                     for part in sensor_parts]
      # Create generators to help iterate through the mount information holders
      joint_in_generator = peekable(itertools.cycle(range(len(joint_ins))))
      neuron_in_generator = peekable(itertools.cycle(range(len(neuron_ins))))
      neuron_out_generator = peekable(itertools.cycle(range(len(neuron_outs))))
      sensor_out_generator = peekable(itertools.cycle(range(len(sensor_outs))))
      generator_list = [joint_in_generator, neuron_in_generator,
                        neuron_out_generator, sensor_out_generator]
      from_sensor = True
      # Create wires
      for part in unused_wires:
          if ((mounts_left(joint_ins) or mounts_left(neuron_ins)) and
              (mounts_left(neuron_outs) or mounts_left(sensor_outs))):
              if part[1].characteristics.to_joint:
                  if from_sensor:
                      if mounts_left(sensor_outs):
                          ind = sensor_out_generator.peek()
                          sensor_outs[ind] = iterate_mounts_used(sensor_outs[ind])
                          if mounts_left(joint_ins):
                              ind = joint_in_generator.peek()
                              joint_ins[ind] = iterate_mounts_used(joint_ins[ind])
                              wire_part = make_wire_part(part, 'S->J', generator_list)
                              from_sensor = False
                              used_wires.append(wire_part)
                          else:
                              ind = neuron_in_generator.peek()
                              neuron_ins[ind] = iterate_mounts_used(neuron_ins[ind])
                              wire_part = make_wire_part(part, 'S->N', generator_list)
                              from_sensor = False
                              used_wires.append(wire_part)
                      else:
                          ind = neuron_out_generator.peek()
                          neuron_outs[ind] = iterate_mounts_used(neuron_outs[ind])
                          if mounts_left(joint_ins):
                              ind = joint_in_generator.peek()
                              joint_ins[ind] = iterate_mounts_used(joint_ins[ind])
                              wire_part = make_wire_part(part, 'N->J', generator_list)
                              from_sensor = False
                              used_wires.append(wire_part)
                          else:
                              ind = neuron_in_generator.peek()
                              neuron_ins[ind] = iterate_mounts_used(neuron_ins[ind])
                              wire_part = make_wire_part(part, 'N->N', generator_list)
                              from_sensor = False
                              used_wires.append(wire_part)
                  else:
                      if mounts_left(neuron_outs):
                          ind = neuron_out_generator.peek()
                          neuron_outs[ind] = iterate_mounts_used(neuron_outs[ind])
                          if mounts_left(joint_ins):
                              ind = joint_in_generator.peek()
                              joint_ins[ind] = iterate_mounts_used(joint_ins[ind])
                              wire_part = make_wire_part(part, 'N->J', generator_list)
                              from_sensor = True
                              used_wires.append(wire_part)
                          else:
                              ind = neuron_in_generator.peek()
                              neuron_ins[ind] = iterate_mounts_used(neuron_ins[ind])
                              wire_part = make_wire_part(part, 'N->N', generator_list)
                              from_sensor = True
                              used_wires.append(wire_part)
                      else:
                          ind = sensor_out_generator.peek()
                          sensor_outs[ind] = iterate_mounts_used(sensor_outs[ind])
                          if mounts_left(joint_ins):
                              ind = joint_in_generator.peek()
                              joint_ins[ind] = iterate_mounts_used(joint_ins[ind])
                              wire_part = make_wire_part(part, 'S->J', generator_list)
                              from_sensor = True
                              used_wires.append(wire_part)
                          else:
                              ind = neuron_in_generator.peek()
                              neuron_ins[ind] = iterate_mounts_used(neuron_ins[ind])
                              wire_part = make_wire_part(part, 'S->N', generator_list)
                              from_sensor = True
                              used_wires.append(wire_part)
              else:
                  if from_sensor:
                      if mounts_left(sensor_outs):
                          ind = sensor_out_generator.peek()
                          sensor_outs[ind] = iterate_mounts_used(sensor_outs[ind])
                          if mounts_left(neuron_ins):
                              ind = neuron_in_generator.peek()
                              neuron_ins[ind] = iterate_mounts_used(neuron_ins[ind])
                              wire_part = make_wire_part(part, 'S->N', generator_list)
                              from_sensor = False
                              used_wires.append(wire_part)
                          else:
                              ind = joint_in_generator.peek()
                              joint_ins[ind] = iterate_mounts_used(joint_ins[ind])
                              wire_part = make_wire_part(part, 'S->J', generator_list)
                              from_sensor = False
                              used_wires.append(wire_part)
                      else:
                          ind = neuron_out_generator.peek()
                          neuron_outs[ind] = iterate_mounts_used(neuron_outs[ind])
                          if mounts_left(neuron_ins):
                              ind = neuron_in_generator.peek()
                              neuron_ins[ind] = iterate_mounts_used(neuron_ins[ind])
                              wire_part = make_wire_part(part, 'N->N', generator_list)
                              from_sensor = False
                              used_wires.append(wire_part)
                          else:
                              ind = joint_in_generator.peek()
                              joint_ins[ind] = iterate_mounts_used(joint_ins[ind])
                              wire_part = make_wire_part(part, 'N->J', generator_list)
                              from_sensor = False
                              used_wires.append(wire_part)
                  else:
                      if mounts_left(neuron_outs):
                          ind = neuron_out_generator.peek()
                          neuron_outs[ind] = iterate_mounts_used(neuron_outs[ind])
                          if mounts_left(neuron_ins):
                              ind = neuron_in_generator.peek()
                              neuron_ins[ind] = iterate_mounts_used(neuron_ins[ind])
                              wire_part = make_wire_part(part, 'N->N', generator_list)
                              from_sensor = True
                              used_wires.append(wire_part)
                          else:
                              ind = joint_in_generator.peek()
                              joint_ins[ind] = iterate_mounts_used(joint_ins[ind])
                              wire_part = make_wire_part(part, 'N->J', generator_list)
                              from_sensor = True
                              used_wires.append(wire_part)
                      else:
                          ind = sensor_out_generator.peek()
                          sensor_outs[ind] = iterate_mounts_used(sensor_outs[ind])
                          if mounts_left(neuron_ins):
                              ind = neuron_in_generator.peek()
                              neuron_ins[ind] = iterate_mounts_used(neuron_ins[ind])
                              wire_part = make_wire_part(part, 'S->N', generator_list)
                              from_sensor = True
                              used_wires.append(wire_part)
                          else:
                              ind = joint_in_generator.peek()
                              joint_ins[ind] = iterate_mounts_used(joint_ins[ind])
                              wire_part = make_wire_part(part, 'S->J', generator_list)
                              from_sensor = True
                              used_wires.append(wire_part)
          else:
              return used_wires
      return used_wires
  
  
  def get_ann_parts(parts_built, frame_parts):
      """Returns a list of parts to be used in the robots ANN.
  
         Order of list is neurons, sensors, wires
  
      """
      neuron_parts = get_neuron_parts(parts_built, frame_parts)
      sensor_parts = get_sensor_parts(parts_built, frame_parts)
      wire_parts = get_wire_parts(parts_built, frame_parts,
                                  neuron_parts, sensor_parts)
      return [neuron_parts, sensor_parts, wire_parts]
  
  
  def setup_frame_parts_to_send(parts_built, frame_parts):
      """Returns a list of frame_part lists to be exported to the 
         Bullet Physics code.
  
         Also exports the correctly rotated body_list.  It is important
         that this list gets used in the function
         setup_sensor_parts_to_send().
  
      """
      body_list = [i for i in parts_built
                   if (i.__class__ == BodyPart and
                       i.characteristics.joint_mount_num > 0)]
      OutputBody = namedtuple('OutputBody', ['index', 'x_loc', 'y_loc',
                                             'z_loc', 'size'])
      bodypart_list = []
      joint_list = [i for i in parts_built
                    if i.__class__ == JointPart]
      OutputJoint = namedtuple('OutputJoint', ['index', 'body1', 'body2',
                                               'x_loc', 'y_loc', 'z_loc',
                                               'x_axis', 'y_axis', 'z_axis',
                                               'lower_limit', 'upper_limit',
                                               'motor'])
      jointpart_list = []
      body_id = 1
      joint_id = 0
      for part in frame_parts[1]:
          if body_id == 1:
              making_base = body_list[frame_parts[0][part.base_body]]
              size = making_base.characteristics.size
              x, y, z = 0., size, 0.
              out_body = OutputBody(body_id
                                    x, y, z,
                                    size)
              bodypart_list.append(out_body)
              body_id += 1
          else:
              body_index = part.other_body
              making_body = body_list[frame_parts[0][body_index]]
              size = making_body.characteristics.size
              base_index = part.base_body
              base = body_list[frame_parts[0][base_index]]
              base_size = base.characteristics.size
              mount_vector = base.characteristics.joint_mount_loc[part.base_mount]
              joint_x = (bodypart_list[base_index].x_loc +
                         base_size * mount_vector[0])
              joint_y += (bodypart_list[base_index].y_loc +
                          base_size * mount_vector[1])
              joint_z += (bodypart_list[base_index].z_loc +
                          base_size * mount_vector[2])
              axis_decider = mount_vector.index(min(mount_vector))
              axis_x = 1 if axis_decider == 0 else 0
              axis_y = 1 if axis_decider == 1 else 0
              axis_z = 1 if axis_decider == 2 else 0
              out_joint = OutputJoint(joint_id,
                                      joint_x, joint_y, joint_z,
                                      axis_x, axis_y, axis_z,
                                      part.characteristics.lower_limit,
                                      part.characteristics.upper_limit,
                                      part.characteristics.motor)
              jointpart_list.append(out_joint)
              joint_id += 1
              x = joint_x + size * mount_vector[0]
              y = joint_y + size * mount_vector[1]
              z = joint_z + size * mount_vector[2]
              rotated_body = making_body.rotate_body(mount_vector)
              body_list[frame_parts[0][body_index]] = rotated_body
              out_body = OutputBody(body_id,
                                    x, y, z,
                                    size)
              bodypart_list.append(out_body)
              body_id += 1
      return [bodypart_list, jointpart_list, body_list]
  
  
  def setup_sensor_parts_to_send(parts_built, frame_parts
                                 rotated_body_list):
      """Returns a list of sensor parts to be exported to the 
         Bullet Physics code.
  
         It is important that function uses the body_list returned 
         by the function setup_frame_parts_to_send().
  
      """
      sensor_parts = get_sensor_parts(parts_built, frame_parts)
      OutputSensor = namedtuple('OutputSensor', ['sensor', 'body_index',
                                                 'mount_x', 'mount_y',
                                                 'mount_z'])
      sensorpart_list = []
      for part in sensor_parts:
          body = rotated_body_list[part.body_index]
          mount_vector = body.characteristics.sensor_mount_loc[part.mount_used]
          x, y, z = mount_vector
          out_sensor = OutputSensor(part.sensor,
                                    part.body_index,
                                    x, y, z)
          sensorpart_list.append(out_sensor)
      return sensorpart_list
  
  
  def find_wire_weight(wire_list, wire_parts, type_from, index_from, type_to, index_to):
      """Returns wire_weight for wire that matches input description.
  
         This is a helper function for make_matrix().
      
      """
      wire_index = [i for i in xrange(len(wire_parts))
                    if (i.from_type == type_from and
                        i.from_index == index_from and
                        i.to_type == type_to and
                        i.to_index == index_to)][0]
      return wire_list[wire_index].weight
  
  
  def make_matrix(wire_list, wire_parts, ins, outs, ins_type, outs_type):
      """Returns a input-->output matrix for the types specified in the inputs.
  
         This is a helper function for setup_ann_matrices_to_send().
  
      """
      matrix = []
      for i in xrange(ins)):
          row = []
          for j in xrange(outs)):
              row.append(find_wire_weight(wire_list, wire_part, ins_type, i,
                                          outs_type, j))
          matrix.append(row)
      return matrix    
  
  
  def setup_ann_matrices_to_send(parts_built, frame_parts, body_list):
      """Returns matrices to be exported to Bullet Physics.
      
      """
      wire_list = [i for i in parts_built
                   if i.__class__ == WirePart]
      neuron_parts, sensor_parts, wire_parts = get_ann_parts(parts_built, frame_parts)
      num_joints = len(frame_parts[1])
      num_neurons = len(neuron_parts)
      num_sensors = len(sensor_parts)
      sensors_to_neurons = make_matrix(wire_list, wire_parts, num_sensors,
                                       num_neurons, SensorPart, NeuronPart)
      neurons_to_neurons = make_matrix(wire_list, wire_parts, num_neurons,
                                       num_neurons, NeuronPart, NeuronPart)
      sensors_to_joints = make_matrix(wire_list, wire_parts, num_sensors,
                                       num_joints, SensorPart, JointPart)
      neurons_to_joints = make_matrix(wire_list, wire_parts, num_neurons,
                                       num_joints, NeuronPart, JointPart)
      return [sensors_to_neurons, neurons_to_neurons,
              sensors_to_joints, neurons_to_joints]
  
#+END_SRC
